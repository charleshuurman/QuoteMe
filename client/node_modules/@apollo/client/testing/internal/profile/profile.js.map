{"version":3,"file":"profile.js","sourceRoot":"","sources":["../../../../src/testing/internal/profile/profile.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from \"react\";\n\nimport { TextEncoder, TextDecoder } from \"util\";\n\nglobal.TextEncoder ??= TextEncoder;\n// @ts-ignore\nglobal.TextDecoder ??= TextDecoder;\nimport type { Render, BaseRender } from \"./Render.js\";\nimport { RenderInstance } from \"./Render.js\";\nimport { applyStackTrace, captureStackTrace } from \"./traces.js\";\n\ntype ValidSnapshot = void | (object & { /* not a function */ call?: never });\n\n/** only used for passing around data internally */\nconst _stackTrace = Symbol();\n/** @internal */\nexport interface NextRenderOptions {\n  timeout?: number;\n  [_stackTrace]?: string;\n}\n\n/** @internal */\nexport interface ProfiledComponent<Props, Snapshot>\n  extends React.FC<Props>,\n    ProfiledComponentFields<Props, Snapshot>,\n    ProfiledComponentOnlyFields<Props, Snapshot> {}\n\ninterface ReplaceSnapshot<Snapshot> {\n  (newSnapshot: Snapshot): void;\n  (updateSnapshot: (lastSnapshot: Readonly<Snapshot>) => Snapshot): void;\n}\n\ninterface MergeSnapshot<Snapshot> {\n  (partialSnapshot: Partial<Snapshot>): void;\n  (\n    updatePartialSnapshot: (\n      lastSnapshot: Readonly<Snapshot>\n    ) => Partial<Snapshot>\n  ): void;\n}\n\ninterface ProfiledComponentOnlyFields<Props, Snapshot> {\n  // Allows for partial updating of the snapshot by shallow merging the results\n  mergeSnapshot: MergeSnapshot<Snapshot>;\n  // Performs a full replacement of the snapshot\n  replaceSnapshot: ReplaceSnapshot<Snapshot>;\n}\ninterface ProfiledComponentFields<Props, Snapshot> {\n  /**\n   * An array of all renders that have happened so far.\n   * Errors thrown during component render will be captured here, too.\n   */\n  renders: Array<\n    Render<Snapshot> | { phase: \"snapshotError\"; count: number; error: unknown }\n  >;\n  /**\n   * Peeks the next render from the current iterator position, without advancing the iterator.\n   * If no render has happened yet, it will wait for the next render to happen.\n   * @throws {WaitForRenderTimeoutError} if no render happens within the timeout\n   */\n  peekRender(options?: NextRenderOptions): Promise<Render<Snapshot>>;\n  /**\n   * Iterates to the next render and returns it.\n   * If no render has happened yet, it will wait for the next render to happen.\n   * @throws {WaitForRenderTimeoutError} if no render happens within the timeout\n   */\n  takeRender(options?: NextRenderOptions): Promise<Render<Snapshot>>;\n  /**\n   * Returns the total number of renders.\n   */\n  totalRenderCount(): number;\n  /**\n   * Returns the current render.\n   * @throws {Error} if no render has happened yet\n   */\n  getCurrentRender(): Render<Snapshot>;\n  /**\n   * Waits for the next render to happen.\n   * Does not advance the render iterator.\n   */\n  waitForNextRender(options?: NextRenderOptions): Promise<Render<Snapshot>>;\n}\n\n/** @internal */\nexport function profile<\n  Snapshot extends ValidSnapshot = void,\n  Props = Record<string, never>,\n>({\n  Component,\n  onRender,\n  snapshotDOM = false,\n  initialSnapshot,\n}: {\n  Component: React.ComponentType<Props>;\n  onRender?: (\n    info: BaseRender & {\n      snapshot: Snapshot;\n      replaceSnapshot: ReplaceSnapshot<Snapshot>;\n      mergeSnapshot: MergeSnapshot<Snapshot>;\n    }\n  ) => void;\n  snapshotDOM?: boolean;\n  initialSnapshot?: Snapshot;\n}) {\n  let nextRender: Promise<Render<Snapshot>> | undefined;\n  let resolveNextRender: ((render: Render<Snapshot>) => void) | undefined;\n  let rejectNextRender: ((error: unknown) => void) | undefined;\n  const snapshotRef = { current: initialSnapshot };\n  const replaceSnapshot: ReplaceSnapshot<Snapshot> = (snap) => {\n    if (typeof snap === \"function\") {\n      if (!initialSnapshot) {\n        throw new Error(\n          \"Cannot use a function to update the snapshot if no initial snapshot was provided.\"\n        );\n      }\n      snapshotRef.current = snap(\n        typeof snapshotRef.current === \"object\" ?\n          // \"cheap best effort\" to prevent accidental mutation of the last snapshot\n          { ...snapshotRef.current! }\n        : snapshotRef.current!\n      );\n    } else {\n      snapshotRef.current = snap;\n    }\n  };\n\n  const mergeSnapshot: MergeSnapshot<Snapshot> = (partialSnapshot) => {\n    replaceSnapshot((snapshot) => ({\n      ...snapshot,\n      ...(typeof partialSnapshot === \"function\" ?\n        partialSnapshot(snapshot)\n      : partialSnapshot),\n    }));\n  };\n\n  const profilerOnRender: React.ProfilerOnRenderCallback = (\n    id,\n    phase,\n    actualDuration,\n    baseDuration,\n    startTime,\n    commitTime\n  ) => {\n    const baseRender = {\n      id,\n      phase,\n      actualDuration,\n      baseDuration,\n      startTime,\n      commitTime,\n      count: Profiled.renders.length + 1,\n    };\n    try {\n      /*\n       * The `onRender` function could contain `expect` calls that throw\n       * `JestAssertionError`s - but we are still inside of React, where errors\n       * might be swallowed.\n       * So we record them and re-throw them in `takeRender`\n       * Additionally, we reject the `waitForNextRender` promise.\n       */\n      onRender?.({\n        ...baseRender,\n        replaceSnapshot,\n        mergeSnapshot,\n        snapshot: snapshotRef.current!,\n      });\n\n      const snapshot = snapshotRef.current as Snapshot;\n      const domSnapshot =\n        snapshotDOM ? window.document.body.innerHTML : undefined;\n      const render = new RenderInstance(baseRender, snapshot, domSnapshot);\n      Profiled.renders.push(render);\n      resolveNextRender?.(render);\n    } catch (error) {\n      Profiled.renders.push({\n        phase: \"snapshotError\",\n        count: Profiled.renders.length,\n        error,\n      });\n      rejectNextRender?.(error);\n    } finally {\n      nextRender = resolveNextRender = rejectNextRender = undefined;\n    }\n  };\n\n  let iteratorPosition = 0;\n  const Profiled: ProfiledComponent<Props, Snapshot> = Object.assign(\n    (props: Props) => (\n      <React.Profiler id=\"test\" onRender={profilerOnRender}>\n        <Component {...(props as any)} />\n      </React.Profiler>\n    ),\n    {\n      replaceSnapshot,\n      mergeSnapshot,\n    } satisfies ProfiledComponentOnlyFields<Props, Snapshot>,\n    {\n      renders: new Array<\n        | Render<Snapshot>\n        | { phase: \"snapshotError\"; count: number; error: unknown }\n      >(),\n      totalRenderCount() {\n        return Profiled.renders.length;\n      },\n      async peekRender(options: NextRenderOptions = {}) {\n        if (iteratorPosition < Profiled.renders.length) {\n          const render = Profiled.renders[iteratorPosition];\n\n          if (render.phase === \"snapshotError\") {\n            throw render.error;\n          }\n\n          return render;\n        }\n        return Profiled.waitForNextRender({\n          [_stackTrace]: captureStackTrace(Profiled.peekRender),\n          ...options,\n        });\n      },\n      async takeRender(options: NextRenderOptions = {}) {\n        let error: unknown = undefined;\n        try {\n          return await Profiled.peekRender({\n            [_stackTrace]: captureStackTrace(Profiled.takeRender),\n            ...options,\n          });\n        } catch (e) {\n          error = e;\n          throw e;\n        } finally {\n          if (!(error && error instanceof WaitForRenderTimeoutError)) {\n            iteratorPosition++;\n          }\n        }\n      },\n      getCurrentRender() {\n        // The \"current\" render should point at the same render that the most\n        // recent `takeRender` call returned, so we need to get the \"previous\"\n        // iterator position, otherwise `takeRender` advances the iterator\n        // to the next render. This means we need to call `takeRender` at least\n        // once before we can get a current render.\n        const currentPosition = iteratorPosition - 1;\n\n        if (currentPosition < 0) {\n          throw new Error(\n            \"No current render available. You need to call `takeRender` before you can get the current render.\"\n          );\n        }\n\n        const render = Profiled.renders[currentPosition];\n\n        if (render.phase === \"snapshotError\") {\n          throw render.error;\n        }\n        return render;\n      },\n      waitForNextRender({\n        timeout = 1000,\n        // capture the stack trace here so its stack trace is as close to the calling code as possible\n        [_stackTrace]: stackTrace = captureStackTrace(\n          Profiled.waitForNextRender\n        ),\n      }: NextRenderOptions = {}) {\n        if (!nextRender) {\n          nextRender = Promise.race<Render<Snapshot>>([\n            new Promise<Render<Snapshot>>((resolve, reject) => {\n              resolveNextRender = resolve;\n              rejectNextRender = reject;\n            }),\n            new Promise<Render<Snapshot>>((_, reject) =>\n              setTimeout(\n                () =>\n                  reject(\n                    applyStackTrace(new WaitForRenderTimeoutError(), stackTrace)\n                  ),\n                timeout\n              )\n            ),\n          ]);\n        }\n        return nextRender;\n      },\n    } satisfies ProfiledComponentFields<Props, Snapshot>\n  );\n  return Profiled;\n}\n\n/** @internal */\nexport class WaitForRenderTimeoutError extends Error {\n  constructor() {\n    super(\"Exceeded timeout waiting for next render.\");\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n}\n\ntype StringReplaceRenderWithSnapshot<T extends string> =\n  T extends `${infer Pre}Render${infer Post}` ? `${Pre}Snapshot${Post}` : T;\n\ntype ResultReplaceRenderWithSnapshot<T> =\n  T extends (...args: infer Args) => Render<infer Snapshot> ?\n    (...args: Args) => Snapshot\n  : T extends (...args: infer Args) => Promise<Render<infer Snapshot>> ?\n    (...args: Args) => Promise<Snapshot>\n  : T;\n\ntype ProfiledHookFields<Props, ReturnValue> =\n  ProfiledComponentFields<Props, ReturnValue> extends infer PC ?\n    {\n      [K in keyof PC as StringReplaceRenderWithSnapshot<\n        K & string\n      >]: ResultReplaceRenderWithSnapshot<PC[K]>;\n    }\n  : never;\n\n/** @internal */\nexport interface ProfiledHook<Props, ReturnValue>\n  extends React.FC<Props>,\n    ProfiledHookFields<Props, ReturnValue> {\n  ProfiledComponent: ProfiledComponent<Props, ReturnValue>;\n}\n\n/** @internal */\nexport function profileHook<ReturnValue extends ValidSnapshot, Props>(\n  renderCallback: (props: Props) => ReturnValue\n): ProfiledHook<Props, ReturnValue> {\n  let returnValue: ReturnValue;\n  const Component = (props: Props) => {\n    ProfiledComponent.replaceSnapshot(renderCallback(props));\n    return null;\n  };\n  const ProfiledComponent = profile<ReturnValue, Props>({\n    Component,\n    onRender: () => returnValue,\n  });\n  return Object.assign(\n    function ProfiledHook(props: Props) {\n      return <ProfiledComponent {...(props as any)} />;\n    },\n    {\n      ProfiledComponent,\n    },\n    {\n      renders: ProfiledComponent.renders,\n      totalSnapshotCount: ProfiledComponent.totalRenderCount,\n      async peekSnapshot(options) {\n        return (await ProfiledComponent.peekRender(options)).snapshot;\n      },\n      async takeSnapshot(options) {\n        return (await ProfiledComponent.takeRender(options)).snapshot;\n      },\n      getCurrentSnapshot() {\n        return ProfiledComponent.getCurrentRender().snapshot;\n      },\n      async waitForNextSnapshot(options) {\n        return (await ProfiledComponent.waitForNextRender(options)).snapshot;\n      },\n    } satisfies ProfiledHookFields<Props, ReturnValue>\n  );\n}\n"]}